<html>

<head>
    <style>


       h1{
            font-family: 'Times New Roman', Times, serif;
            font-size: 35px;
            color:rgb(114, 1, 114);
            margin-top: 12px;
          }
          
       
        p{
            font-size: 21px;
            font-family: 'Times New Roman', Times, serif;
        }

        li{
            font-size: 25px;
            font-family: 'Times New Roman', Times, serif;
            color: blue;
            font-weight: bold;
        }
        b{
            font-weight: bold;
            font-size: 24px;
        }
        b1{
            font-weight: bold;
            font-size: 22px;
            background-color: white;
        }
        
        img{
    width: 60%;
    height: 82%;
}

h2 img{
    width: 65%;
    height: 73%;
}
h3 img{
    width: 60%;
    height: 60%;
}
    
        
button {
            width: 110px;
            height: 40px;
            font-family: 'Times New Roman', Times, serif;
            font-size: 25px;
            background-color: darkgray;
            color: white;
            border: none;
            
            
        }
        
        
    </style>
</head>
    <body>
     <br>
      

    <h1>Implicit /Explicit Cursor Attributes</h1><br>

    <p><b>They are various Attributes used in the cursor : </b></p>

   <p><b1>(i) %FOUND : </b1>Its return value is TRUE if DML statements like INSERT, DELETE and UPDATE affect at least one row or more rows or a SELECT INTO statement returned one or more rows. Otherwise it returns FALSE.</p>

   <p><b1>(ii) %NOTFOUND : </b1>Its return value is TRUE if DML statements like INSERT, DELETE and UPDATE affect no row, or a SELECT INTO statement return no rows. Otherwise it returns FALSE. It is a just opposite of %FOUND.</p>

   <p><b1>(iii) %ROWCOUNT : </b1>It returns the number of rows affected by DML statements like INSERT, DELETE, and UPDATE or returned by a SELECT INTO statement.</p>

   <p><b1>(iv) %ISOPEN : </b1>It always returns FALSE for implicit cursors, because the SQL cursor is automatically closed after executing its associated SQL statements.</p><br>

   
   <h1>Implicit Cursors</h1>
   <p>The implicit cursors are automatically generated by Oracle while an SQL statement is executed, if you don't use an explicit cursor for the statement.  <br>
    These are created by default to process the statements when DML statements like INSERT, UPDATE, DELETE etc. are executed.</p>

    <li>The Example of Implicit Cursors</li>
    <p>Select * from student1;</p>
    <h3><img src="./images/student1 tabl.png"></h3><br>
    <p>Declare   <br> 
        total_rows number(2); <br>  
     Begin  <br>
        update  student1  <br> 
        set marks = marks + 5;  <br> 
        if sql%notfound then   <br>
           dbms_output.put_line('no student marks updated');   <br>
        elsif sql%found then  <br>
           total_rows := sql%rowcount;   <br>
       dbms_output.put_line( total_rows || ' student marks updated ');  <br>    
    end if;    <br>
    end;  </p>
    <img src="./images/implict.png"><br><br>
    <p>Select * from student1;</p>
    <h3><img src="./images/student1 21.png"></h3><br><br>


<h1>Explicit Cursors</h1>
<p>The Explicit cursors are defined by the programmers to gain more control over the context area. These cursors should be defined in the declaration section of the PL/SQL block. It is created on a SELECT statement which returns more than one row.</p><br>

<b>Steps for Explicit Cursors : </b>
<p>1. Declare  <br>
   2. open   <br>
   3. fetch  <br>
   4. close </p>

<p><b1>1. Declare : </b1>It defines the cursor with a name and the associated SELECT statement.   <br><br>
  <b>Syntax of Declare Cursors : </b> <br>
   CURSOR name IS <br> 
    SELECT statement; </p>


<p><b1>2. open : </b1>It is used to allocate memory for the cursor and make it easy to fetch the rows returned by the SQL statements into it.   <br><br>
<b>Syntax of open Cursors : </b> <br>
    OPEN cursor_name;  </p>

<p><b1>3. fetch : </b1>It is used to access one row at a time. You can fetch rows from the above-opened cursor as follows  <br><br>
<b>Syntax of fetch the Cursors : </b>  <br>
  FETCH cursor_name INTO variable_list;   </p>

<p><b1>4. close : </b1>It is used to release the allocated memory. The following syntax is used to close the above-opened cursors. <br><br>
<b>Syntax of close the Cursors : </b><br>
  Close cursor_name;  </p><br>


<li>Syntax of  Explicit Cursors</li>
<p>CURSOR cursor_name IS select_statement;</p><br>

<li>Example of  Explicit Cursors</li>
<p>declare  <br>
    cursor c1 IS select* from student1 where marks<30;  <br>
    srol student1.Rollno%type;  <br>
    sname student1.Name%type; <br> 
    smark student1.MARKS%type;  <br>
    begin  <br>
    open c1;  <br>
    loop  <br>
    fetch c1 into srol,sname,smark; <br> 
    exit when c1%notfound;  <br>
    Dbms_output.put_line(srol||' '||sname||' '||smark);  <br> 
    end loop;  <br>
    dbms_output.put_line(c1%rowcount||' rows are displayed'); <br> 
    close c1;  <br>
    end; </p><br>

<h2><img src="./images/explicit1.png"></h2><br>


<h1>Cursor for loop</h1>
<p>The cursor FOR LOOP implicitly its loop index as a record of type%ROWTYPE, opens a cursor, repeatedly fetcges rows of the values from the active set into fields in the record, and then close the cursor when all rows have been processed or when the EXIT command is encountered.</p><br>

<li>Example of  Cursor for loop</li>
<p>declare <br>
    cursor c1 IS select name from student1 where rollno=1; <br>
    begin <br>
    for i in c1 loop <br>
    Dbms_output.put_line(i.Name); <br> 
    end loop; <br>
    end; </p><br>
<h2><img src="./images/for cursor1.png"></h2>  <br><br>


<button onclick="history.back()">Back</button><br>


</body></html>







